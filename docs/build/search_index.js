var documenterSearchIndex = {"docs":
[{"location":"api.html#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"This page provides a complete list of all exported functions and types.","category":"page"},{"location":"api.html#MultifractalTools.bin_data-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Integer}} where T<:Number","page":"API Reference","title":"MultifractalTools.bin_data","text":"bin_data(data::AbstractMatrix, l::Integer) -> Matrix\n\nPerforms spatial coarse-graining (binning) of the data.\n\nThis function divides the input data matrix into non-overlapping square  boxes of size l x l. It calculates the \"measure\" (probability) in each  box by summing the abs2 of all elements within that box.\n\nThe abs2 (e.g., |ψ|^2) is used, as the multifractal measure μ is  typically a probability distribution.\n\nArguments\n\ndata::AbstractMatrix: The input 2D data, assumed to be renormalized  (though not strictly required).\nl::Integer: The side length of the square bins.\n\nReturns\n\nA new Matrix (named BinnedData) of size floor.(size(data) ./ l),  where each element is the sum of abs2(data[...]) within that bin.\n\nExamples\n\n```jldoctest julia> A = [1.0 1.0 2.0 2.0;              1.0 1.0 2.0 2.0;              3.0 3.0 4.0 4.0;              3.0 3.0 4.0 4.0] 4×4 Matrix{Float64}:  1.0  1.0  2.0  2.0  1.0  1.0  2.0  2.0  3.0  3.0  4.0  4.0  3.0  3.0  4.0  4.0\n\nBin with l=2\n\nBox 1 (top-left): 1²+1²+1²+1² = 4\n\nBox 2 (top-right): 2²+2²+2²+2² = 16\n\nBox 3 (bottom-left): 3²+3²+3²+3² = 36\n\nBox 4 (bottom-right): 4²+4²+4²+4² = 64\n\njulia> MultifractalTools.bin_data(A, 2) 2×2 Matrix{Float64}:   4.0  16.0  36.0  64.0\n\n\n\n\n\n","category":"method"},{"location":"api.html#MultifractalTools.compute_scaling_quantities-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{<:Real}}} where T<:Number","page":"API Reference","title":"MultifractalTools.compute_scaling_quantities","text":"compute_scaling_quantities(data, qs; ls=Integer[], crop_to_best_fit=true, crop_ratio=0.1)\n\nComputes the core scaling quantities required for multifractal analysis.\n\nThis function calculates the partition function Z(q l), the entropy S(q l),  and the average log(mu) weighted by mu^q (which we call Z(q l)) for a given  data matrix, across a range of q values and box sizes l.\n\nArguments\n\ndata::AbstractMatrix: The input 2D data (e.g., a wavefunction or probability distribution).\nqs::AbstractVector: A vector of q values (the \"moments\") to analyze.\n\nKeyword Arguments\n\nls::AbstractVector{<:Integer}: An optional vector of box sizes l to use. If left empty  (default), the function will automatically determine box sizes based on the data size  and other keyword arguments.\ncrop_to_best_fit::Bool: If true (default) and ls is empty, the function will find  the largest \"best\" square size (with the most divisors) within crop_ratio of the  original data size. If false, it uses the full data size.\ncrop_ratio::Float64: The fraction of the data size to search for a \"best\" size  (default: 0.1). For a 1000x1000 matrix, it will search from 900-1000.\n\nReturns\n\nA NamedTuple containing:\nls: The vector of box sizes l that were used.\nZqs: An (l, q) matrix of the partition functions, Z(q l) = sum_i mu_i^q.\nSqs: An (l, q) matrix of the information entropies, S(q l) = sum_i p_i log(p_i).\nZPrimes: An (l, q) matrix of the weighted log averages, Z(q l) = sum_i p_i log(mu_i).\n\nExamples\n\n```jldoctest julia> data = rand(128, 128); julia> qs = obtainqs(-5, 5, 11); julia> scalingdata = computescalingquantities(data, qs; croptobestfit=false); julia> scalingdata.ls 8-element Vector{Int64}:    1    2    4    8   16   32   64  128\n\n\n\n\n\n","category":"method"},{"location":"api.html#MultifractalTools.compute_spectrum-Tuple{NamedTuple, AbstractVector{<:Real}, Integer, Integer}","page":"API Reference","title":"MultifractalTools.compute_spectrum","text":"compute_spectrum(ScalingQuantities, qs, λ1, λ2) -> NamedTuple\n\nCalculates the multifractal spectrum exponents ($\tau(q) lpha(q), f(lpha)) by fitting the results from compute_scaling_quantities.\n\nThis function performs a linear regression in log-log space to find the scaling exponents. For example, the multifractal exponent $\tau(q)$ is found by fitting the power law Z(q psilon) sim psilon^\tau(q), which becomes linear in log space: log(Z) = \tau(q) log(psilon) + C.\n\nThe function fits this linear relationship using the power_law_model for $\tau(q) lpha(q), and f(lpha) simultaneously.\n\nArguments\n\nScalingQuantities::NamedTuple: The NamedTuple output from compute_scaling_quantities.\nqs::AbstractVector: The vector of q values. This must be the same qs vector used to generate the ScalingQuantities.\nλ1::Integer: The starting index (not value) from ScalingQuantities.ls to use for the linear fit.\nλ2::Integer: The ending index from ScalingQuantities.ls to use for the linear fit.\n\nReturns\n\nA NamedTuple containing the calculated spectra:\nqs: The q values.\nτqs: The vector of multifractal exponents, $\tau(q)$.\nαs: The vector of singularity spectrum lpha(q).\nfs: The vector of singularity spectrum f(lpha).\n\nExamples\n\n```jldoctest julia> data = rand(128, 128); julia> qs = MultifractalTools.obtainqs(-5, 5, 3); # -5.0, 0.0, 5.0 julia> scalingdata = MultifractalTools.computescalingquantities(data, qs); julia> scaling_data.ls 8-element Vector{Int64}:    1    2    4    8   16   32   64  128\n\nWe fit using the scaling range from index 2 (l=2) to index 6 (l=32)\n\njulia> spectrum = computespectrum(scalingdata, qs, 2, 6); julia> spectrum.τqs 3-element Vector{Float64}:   1.9999999999999996  -0.0  -2.0\n\n\n\n\n\n","category":"method"},{"location":"api.html#MultifractalTools.find_best_scaling_size-Tuple{Integer, Float64}","page":"API Reference","title":"MultifractalTools.find_best_scaling_size","text":"find_best_scaling_size(max_size::Integer, crop_ratio::Float64) -> NamedTuple\n\nFinds an optimal square size for box-counting analysis near max_size.\n\nThis function searches for an integer n in the range  [floor(max_size * (1 - crop_ratio)), max_size] that has the maximum number  of divisors. This is useful for maximizing the number of available scaling  sizes (l values) for the analysis, which improves the quality of the  linear fits.\n\nArguments\n\nmax_size::Integer: The largest possible size (e.g., minimum(size(data))).\ncrop_ratio::Float64: The fraction of the max_size to search within.  For example, 0.1 searches in the top 10% of the range.\n\nReturns\n\nA NamedTuple with two fields:\nsize: The integer n found to have the most divisors.\ndivisors: A Vector{Int} of the divisors of n.\n\nExamples\n\n```jldoctest\n\nSearch in the range [90, 100]\n\n96 has 12 divisors: [1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 96]\n\n100 has 9 divisors: [1, 2, 4, 5, 10, 20, 25, 50, 100]\n\njulia> result = MultifractalTools.findbestscaling_size(100, 0.1);\n\njulia> result.size 96\n\njulia> result.divisors 12-element Vector{Int64}:   1   2   3   4   6   8  12  16  24  32  48  96\n\n\n\n\n\n","category":"method"},{"location":"api.html#MultifractalTools.get_divisors-Tuple{Integer}","page":"API Reference","title":"MultifractalTools.get_divisors","text":"get_divisors(n::Integer) -> Vector{Int}\n\nFinds all positive divisors of an integer n and returns them in a sorted vector.\n\nThe function computes divisors by iterating up to sqrt(n) for efficiency. It correctly handles n=0 (returning an empty list) and negative numbers (by taking the absolute value).\n\nArguments\n\nn::Integer: The number to find the divisors of.\n\nReturns\n\nA Vector{Int} containing all divisors of n in ascending order.\n\nExamples\n\n```jldoctest julia> MultifractalTools.get_divisors(100) 9-element Vector{Int64}:    1    2    4    5   10   20   25   50  100\n\njulia> MultifractalTools.get_divisors(17) 2-element Vector{Int64}:   1  17\n\n\n\n\n\n","category":"method"},{"location":"api.html#MultifractalTools.obtain_qs-Tuple{Number, Number, Integer}","page":"API Reference","title":"MultifractalTools.obtain_qs","text":"obtain_qs(qmin::Number, qmax::Number, num_q::Integer) -> Vector{Float64}\n\nGenerates a vector of num_q q-values, linearly spaced between qmin and qmax.\n\nArguments\n\nqmin: The minimum value for the q range.\nqmax: The maximum value for the q range.\nnum_q: The number of q values to generate.\n\nReturns\n\nA Vector of Float64 values.\n\nExamples\n\n```jldoctest julia> obtain_qs(-5, 5, 3) 3-element Vector{Float64}:  -5.0   0.0   5.0\n\n\n\n\n\n","category":"method"},{"location":"api.html#MultifractalTools.renormalize_data-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Number","page":"API Reference","title":"MultifractalTools.renormalize_data","text":"renormalize_data(data::AbstractMatrix)\n\nNormalizes the input data matrix according to its L^2-norm.\n\nThis ensures that the sum of the absolute squares of the elements is equal to 1. Mathematically, this computes: D = D  sqrtsum D_ij^2\n\nThis is typically the first step in a multifractal analysis to treat the data as a probability distribution (psi^2 = 1).\n\nArguments\n\ndata::AbstractMatrix: The input 2D data.\n\nReturns\n\nA new AbstractMatrix of the same size, with its elements scaled.\n\nExamples\n\n```jldoctest julia> A = [1.0 1.0; 1.0 1.0] 2×2 Matrix{Float64}:  1.0  1.0  1.0  1.0\n\njulia> B = MultifractalTools.renormalize_data(A);\n\njulia> sum(abs2.(B)) 1.0\n\n\n\n\n\n","category":"method"},{"location":"index.html#MultifractalTools.jl","page":"Home","title":"MultifractalTools.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Welcome to the documentation for MultifractalTools.jl.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This package provides a set of tools for performing multifractal analysis.","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"MultifractalTools\")","category":"page"},{"location":"index.html#Example-Usage","page":"Home","title":"Example Usage","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Here is a quick example of how to use the package. We can also embed plots!","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using MultifractalTools\nusing GLMakie\n\n# Create some sample data\ndata = rand(128, 128)\n\n# 1. Get q values\nqs = obtain_qs(-10, 10, 21)\n\n# 2. Compute scaling quantities\nscaling_data = compute_scaling_quantities(data, qs)\n\n# 3. Compute the spectrum (using a subset of scaling)\nspec = compute_spectrum(scaling_data, qs, 2, 6)\n\n# 4. Plot the spectrum\n# We call the plotting function directly\nplot_spectrum(spec, which=:Spectrum)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using MultifractalTools\nusing GLMakie\ndata = rand(128, 128)\n\n# 1. Get q values\nqs = obtain_qs(-10, 10, 21)\n\n# 2. Compute scaling quantities\nscaling_data = compute_scaling_quantities(data, qs)\n\n# 3. PLot the scaling quantities to analyze the fitting interactively!\nfig = plot_to_fit(scaling_data, qs)\ndisplay(fig) #This should open a new window if one is on a jupyter notebook!\n\n# 4. Compute the spectrum (using a subset of scaling)\nspec = compute_spectrum(scaling_data, qs, 2, 6)\n\n# 4. Plot the spectrum\nplot_spectrum(spec, which=:Spectrum)\n","category":"page"},{"location":"index.html#Page-Index","page":"Home","title":"Page Index","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"","category":"page"}]
}
